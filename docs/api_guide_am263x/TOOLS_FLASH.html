<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<title>AM263x MCU+ SDK: Flashing Tools</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="AM263x MCU+ SDK"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AM263x MCU+ SDK
   &#160;<span id="projectnumber">11.00.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.html" method="get">
              <img id="MSearchSelect" src="search/mag.svg" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('TOOLS_FLASH.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Flashing Tools </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md1345">Introduction</a></li>
<li class="level1"><a href="#TOOLS_TI_UNIFLASH_TOOL">TI Uniflash</a><ul><li class="level2"><a href="#autotoc_md1346">JTAG Session</a></li>
<li class="level2"><a href="#autotoc_md1347">Serial (UART) Session</a></li>
</ul>
</li>
<li class="level1"><a href="#TOOLS_FLASH_UART_UNIFLASH">UART Uniflash</a><ul><li class="level2"><a href="#autotoc_md1348">Tool requirements on host PC</a></li>
<li class="level2"><a href="#autotoc_md1349">Important files and folders</a></li>
<li class="level2"><a href="#BASIC_STEPS_TO_FLASH_FILES">Basic steps to flash files</a><ul><li class="level3"><a href="#autotoc_md1350">Getting ready to flash</a></li>
<li class="level3"><a href="#autotoc_md1351">Flash configuration file</a></li>
<li class="level3"><a href="#autotoc_md1352">Flashing the files</a></li>
<li class="level3"><a href="#autotoc_md1353">Flash tool options</a></li>
</ul>
</li>
<li class="level2"><a href="#TOOLS_FLASH_ERROR_MESSAGES">Flash tool error messages and solutions</a></li>
<li class="level2"><a href="#autotoc_md1354">Detailed sequence of steps that happen when flashing files</a></li>
<li class="level2"><a href="#TOOLS_UART_UNIFLASH_GUI">GUI for UART Uniflash (Experimental)</a><ul><li class="level3"><a href="#autotoc_md1355">Pre-Requisites for UART Uniflash GUI</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md1356">Using the UART Uniflash GUI</a></li>
<li class="level2"><a href="#autotoc_md1357">Important Notes and Common Pitfalls in UART Uniflash GUI</a></li>
</ul>
</li>
<li class="level1"><a href="#TOOLS_FLASH_JTAG_UNIFLASH">JTAG Uniflash</a><ul><li class="level2"><a href="#autotoc_md1358">Sequence of steps that happen when flashing via JTAG</a></li>
<li class="level2"><a href="#autotoc_md1359">Important files and folders</a></li>
<li class="level2"><a href="#autotoc_md1360">Basic steps to flash files</a></li>
</ul>
</li>
<li class="level1"><a href="#TOOLS_FLASH_CAN_UNIFLASH">CAN Uniflash</a><ul><li class="level2"><a href="#autotoc_md1361">Important files and folders</a></li>
<li class="level2"><a href="#autotoc_md1362">Basic steps to flash files</a></li>
</ul>
</li>
<li class="level1"><a href="#TOOLS_FLASH_ENET_UNIFLASH">ENET Uniflash</a><ul><li class="level2"><a href="#autotoc_md1363">Tool requirements on host PC</a></li>
<li class="level2"><a href="#autotoc_md1364">Important files and folders</a></li>
<li class="level2"><a href="#BASIC_STEPS_TO_FLASH_FILES_OVER_ENET">Basic steps to flash files over ethernet</a><ul><li class="level3"><a href="#autotoc_md1365">Getting ready to flash</a></li>
<li class="level3"><a href="#autotoc_md1366">Flash configuration file</a></li>
<li class="level3"><a href="#autotoc_md1367">Flashing the files over ethernet</a></li>
<li class="level3"><a href="#autotoc_md1368">Flash tool options</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_components_tools_tools_flash"></a></p>
<h1><a class="anchor" id="autotoc_md1345"></a>
Introduction</h1>
<p>Flashing tools allow to flash binaries to the flash on a EVM.</p>
<ul>
<li><a class="el" href="TOOLS_FLASH.html#TOOLS_TI_UNIFLASH_TOOL">TI Uniflash</a></li>
<li><a class="el" href="TOOLS_FLASH.html#TOOLS_FLASH_UART_UNIFLASH">UART Uniflash</a></li>
<li><a class="el" href="TOOLS_FLASH.html#TOOLS_FLASH_JTAG_UNIFLASH">JTAG Uniflash</a></li>
<li><a class="el" href="TOOLS_FLASH.html#TOOLS_FLASH_CAN_UNIFLASH">CAN Uniflash</a></li>
</ul>
<h1><a class="anchor" id="TOOLS_TI_UNIFLASH_TOOL"></a>
TI Uniflash</h1>
<dl class="section note"><dt>Note</dt><dd>Sitara MCU devices now supports TI Uniflash Tool for loading/flashing images into the target. Please refer <a class="el" href="TI_UNIFLASH_TOOL.html">TI Uniflash Tool</a> for more details.</dd></dl>
<h2><a class="anchor" id="autotoc_md1346"></a>
JTAG Session</h2>
<ol type="1">
<li>Set the board in <a class="el" href="EVM_SETUP_PAGE.html#BOOTMODE_NOBOOT">DEVBOOT MODE</a> mode and do a power cycle prior to loading.</li>
<li>Choose a Program to Flash:<ul>
<li>Click the "Browse" button to select the program you want to flash.</li>
<li>The default start address is automatically filled. UniFlash requires the full address since flash offsets are not supported.  <style>div.image img[src="load_jtag_1.png"]{width:70%}</style> <div class="image">
<img src="load_jtag_1.png" alt=""/>
<div class="caption">
Load Binary Image</div></div>
</li>
<li>Do not modify the address field for XIP file type. The field is used by the flash loader to recognize XIP files.</li>
</ul>
</li>
<li>Flash Address Table:<ul>
<li>The table below shows the flash addresses accepted by the ROM/SBL to load programs onto the target: <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Program  </th><th class="markdownTableHeadNone">Start Address   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">SBL  </td><td class="markdownTableBodyNone">0x60000000   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Application  </td><td class="markdownTableBodyNone">0x60080000   </td></tr>
</table>
</li>
<li>Edit the application offset field only, if your sbl is configured with custom application offset</li>
</ul>
</li>
<li>Initiating Programming:<ul>
<li>After clicking "Load Image," UniFlash starts the programming process, and the console displays a log of each operation. <b>[SUCCESS] Program Load completed successfully</b> will get printed in the console, if the program loads into the target successfully.</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md1347"></a>
Serial (UART) Session</h2>
<ol type="1">
<li>Set the board in <a class="el" href="EVM_SETUP_PAGE.html#BOOTMODE_UART">UART BOOT MODE</a> mode and do a power cycle.</li>
<li>Enter the appropriate COM Port and select the board type. Make sure the UART port used for terminal is identified as mentioned in <a class="el" href="EVM_SETUP_PAGE.html#CCS_UART_TERMINAL">Setup UART Terminal</a> <div class="image">
<img src="uart_com.png" alt=""/>
<div class="caption">
COM Port Selection</div></div>
</li>
<li>Choose a Program to Flash:<ul>
<li>Click the "Browse" button to select the program you want to flash. Serial Uniflash session supports three binary image formats - SBL, application image, XIP application image. It is not necessary to have three images in order to carry out the operation.</li>
<li>The SBL and application image flash offsets are handled internally based on the device's SBL configuration.  <style>div.image img[src="uart_load_1.png"]{width:80%}</style> <div class="image">
<img src="uart_load_1.png" alt=""/>
<div class="caption">
Load Binary Image</div></div>
</li>
<li>Change the application offset from the settings. This step is only needed if you are using sbl with custom application offset.  <style>div.image img[src="image_offset.png"]{width:80%}</style> <div class="image">
<img src="image_offset.png" alt=""/>
<div class="caption">
Custom Application Offset</div></div>
</li>
</ul>
</li>
<li>Initiating Programming:<ul>
<li>After clicking "Load Image," UniFlash starts the programming process, and the console displays a log of each operation. <b>[SUCCESS] Program Load completed successfully</b> will get printed in the console, if the program loads into the target successfully.</li>
</ul>
</li>
</ol>
<h1><a class="anchor" id="TOOLS_FLASH_UART_UNIFLASH"></a>
UART Uniflash</h1>
<p>UART is used as the transport or interface to send the file to flash to the EVM.</p>
<h2><a class="anchor" id="autotoc_md1348"></a>
Tool requirements on host PC</h2>
<ul>
<li>The tool is implemented using python and needs python version 3.x</li>
<li>The tool uses additional python packages as listed below.<ul>
<li>pyserial for UART access on PC</li>
<li>xmodem for the file transfer protocol</li>
<li>tqdm for progress bar when the tool is run</li>
</ul>
</li>
<li>Refer to the page, <a class="el" href="SDK_DOWNLOAD_PAGE.html#INSTALL_PYTHON3">Python3</a> , to install python and the required python packages on your PC.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1349"></a>
Important files and folders</h2>
<table class="doxtable">
<tr>
<th>Folder/Files </th><th>Description  </th></tr>
<tr>
<td colspan="2" bgcolor="#F0F0F0">${SDK_INSTALL_PATH}/tools/boot/ </td></tr>
<tr>
<td>uart_uniflash.py </td><td>Flashing tool  </td></tr>
<tr>
<td>sbl_prebuilt/am263x-cc </td><td>Pre-built bootloader images and default flash configuration files for a supported EVM  </td></tr>
<tr>
<td colspan="2" bgcolor="#F0F0F0">${SDK_INSTALL_PATH}/examples/drivers/boot/ </td></tr>
<tr>
<td>sbl_uart_uniflash </td><td><p class="starttd">Flashing application that is run on the EVM to receive files to flash </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>sbl_qspi_multicore_elf </td><td>QSPI bootloader application that needs to be flashed at offset 0x0. When in QSPI boot mode, this bootloader application will boot the user mcelf application file for all the CPUs  </td></tr>
<tr>
<td>sbl_qspi_fastboot </td><td>QSPI bootloader application that needs to be flashed at offset 0x0. When in QSPI boot mode, this bootloader application will boot the user mcelf file for all the CPUs with the fastest boot time.  </td></tr>
<tr>
<td>sbl_can_multicore_elf </td><td>CAN bootloader application that needs to be flashed at offset 0x0. When in QSPI boot mode, this bootloader application will boot the mcelf application file for all the CPUs  </td></tr>
<tr>
<td>sbl_can_uniflash_multicore_elf </td><td>CAN Uniflash application that needs to be flashed at offset 0x0. When in QSPI boot mode, this uniflash application will wait for CAN packets to flash the user mcelf application file via CAN using the can_uniflash python script. This application has capability to boot the application as well.  </td></tr>
<tr>
<td>sbl_sd_multicore_elf </td><td><p class="starttd">SD bootloader application that needs to be flashed at offset 0x0. When in QSPI boot mode, this bootloader application will boot the user mcelf application file from SD card for all the CPUs </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>sbl_null </td><td>SOC init bootloader application that can be used to init the SOC when working in CCS IDE environment.  </td></tr>
</table>
<h2><a class="anchor" id="BASIC_STEPS_TO_FLASH_FILES"></a>
Basic steps to flash files</h2>
<h3><a class="anchor" id="autotoc_md1350"></a>
Getting ready to flash</h3>
<ul>
<li>Make sure the flashing application (<code>sbl_uart_uniflash</code>), QSPI bootloader (<code>sbl_qspi_multicore_elf</code>), and the user application (<code>*.mcelf</code>) you want to flash is built for the EVM.<ul>
<li>For every supported EVM pre-built flashing application and QSPI bootloader can be found below <pre class="fragment">{SDK_INSTALL_PATH}/tools/boot/sbl_prebuilt/{board}
</pre></li>
<li>The flashing application and QSPI bootloader source code can be found at below path <pre class="fragment">{SDK_INSTALL_PATH}/examples/drivers/boot
</pre></li>
<li>If you have modified the flashing or bootloader applications, make sure to rebuild these applications and note the path to the <code>.tiimage</code> files that are generated as part of the build.</li>
<li>To build your application follow the steps mentioned in <a class="el" href="GETTING_STARTED_BUILD.html">Build a Hello World example</a> to build the application you want. Note the path to the <code>*.mcelf</code> file that is generated as part of the build.</li>
</ul>
</li>
<li>Make sure you have installed python as mention in <a class="el" href="SDK_DOWNLOAD_PAGE.html#INSTALL_PYTHON3">Python3</a></li>
<li>Make sure you have identified the UART port on the EVM as mentioned in <a class="el" href="EVM_SETUP_PAGE.html">EVM Setup</a></li>
</ul>
<h3><a class="anchor" id="autotoc_md1351"></a>
Flash configuration file</h3>
<ul>
<li>Create a flash configuration file, using the default flash configuration file present at below as reference <pre class="fragment">  ${SDK_INSTALL_PATH}/tools/boot/sbl_prebuilt/{board}/mcelf_sbl_qspi.cfg
</pre></li>
<li>In this config file, modify the paths to the flashing application and QSPI bootloader, in case you are not using the pre-built applications <pre class="fragment">  --flash-writer={path to flash application .tiimage}
  --file={path to QSPI bootloader .tiimage} --operation=flash --flash-offset=0x0
</pre></li>
<li>Edit below line to point to the user application (<code>.mcelf</code>) file <pre class="fragment">  --file={path to your application .mcelf file} --operation=flash --flash-offset=0x80000
</pre></li>
</ul>
<h3><a class="anchor" id="autotoc_md1352"></a>
Flashing the files</h3>
<ul>
<li>Set EVM in <a class="el" href="EVM_SETUP_PAGE.html#BOOTMODE_UART">UART BOOT MODE</a> and power on the EVM</li>
<li>Run below python command on the Windows command prompt (<code>cmd.exe</code>) or Linux bash shell to flash the files. <pre class="fragment">  cd ${SDK_INSTALL_PATH}/tools/boot
  python uart_uniflash.py -p {name of your UART com port} --cfg={path to your edited config file}
</pre></li>
<li>At each step in the flashing your will see success or error messages, including progress as the file is being transferred.</li>
<li>If flashing is successful, power OFF the EVM, set the EVM to <a class="el" href="EVM_SETUP_PAGE.html#BOOTMODE_QSPI">QSPI BOOT MODE</a> and power ON the EVM to run the flashed application.</li>
<li>If flashing is not successful, then check the error messages and take appropriate action (See <a class="el" href="TOOLS_FLASH.html#TOOLS_FLASH_ERROR_MESSAGES">Flash tool error messages and solutions</a>).</li>
</ul>
<h3><a class="anchor" id="autotoc_md1353"></a>
Flash tool options</h3>
<ul>
<li>Type below to see all the possible options with the flashing tool and also see the default .cfg file for syntax and options possible in the config file <pre class="fragment">  cd ${SDK_INSTALL_PATH}/tools/boot
  python uart_uniflash.py --help
</pre></li>
</ul>
<h2><a class="anchor" id="TOOLS_FLASH_ERROR_MESSAGES"></a>
Flash tool error messages and solutions</h2>
<p>If the flashing fails, the error message will give a hint as to why it failed. Some common error messages, reasons and potential solutions are listed below.</p>
<table class="doxtable">
<tr>
<th>Error </th><th>Possible Reason </th><th>Solution  </th></tr>
<tr>
<td>Serial port not found or not accessible </td><td>Wrong UART port passed as argument or the UART port is open in some other terminal application. </td><td>Check the UART port, UART ports are named as <code>COM1</code>, <code>COM2</code>, and so on in Windows and as <code>/dev/ttyUSB0</code>, <code>/dev/ttyUSB1</code>, and so on in Linux. Also make sure to close all open UART terminals and try again.  </td></tr>
<tr>
<td>No response or error response from EVM. </td><td>Either EVM is not in power-ON state or EVM is not setup in UART boot mode. </td><td>Use Ctrl-C to terminate the script if it is stuck. Check UART boot mode switch setting, check power to EVM, power-cycle EVM and try again  </td></tr>
<tr>
<td>Flashing failed error message </td><td>This should not happen ideally on TI EVMs. On custom EVM this could happen if there is some issue in the flash driver on the EVM. </td><td>Power cycle EVM and try again. If the problem still does not go away, then likely the flash on the EVM has gone bad. Try other SOC initialization options and check the flash driver via CCS IDE debug.  </td></tr>
<tr>
<td>Config file parsing error </td><td>Wrong config file passed or input files not found. </td><td>Check the message that is printed, and edit the config file to fix the parsing errors. Make sure to specify file paths with forward slash <code>/</code>, including in Windows. The default config file should not have any errors though.  </td></tr>
<tr>
<td>Python not found error or python packages not not found error </td><td>Python or python packages needed for this script are not installed </td><td>Follow steps mentioned in <a class="el" href="SDK_DOWNLOAD_PAGE.html#INSTALL_PYTHON3">Python3</a> to install python and related packages  </td></tr>
<tr>
<td>Parsing config file error </td><td>SBL binaries are missing from the prebuilt folder </td><td>Build sbl using below command:<div class="fragment"><div class="line">gmake -s sbl DEVICE=am243x </div>
</div><!-- fragment -->  </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md1354"></a>
Detailed sequence of steps that happen when flashing files</h2>
<dl class="section note"><dt>Note</dt><dd>This section has more detailed sequence of steps that happen underneath the tools and on the EVM for reference.</dd></dl>
<p>The detailed sequence of steps that happen when flashing files is listed below, refer to the <a class="el" href="EVM_SETUP_PAGE.html">EVM Setup</a> page to see how to setup the EVM in different boot modes that are needed for this sequence of steps.</p>
<ul>
<li>Set EVM in UART boot mode and power it on, the SOC ROM bootloader waits to receive a file using the UART+XMODEM protocol.</li>
<li>PC sends the flashing application file (<code>sbl_uart_uniflash.release.tiimage</code>) via the flashing tool using UART+XMODEM protocol underneath.</li>
<li>The ROM bootloader, boots the flashing application</li>
<li>The flashing application now initializes the flash on the EVM and waits for additional commands using UART+XMODEM protocol</li>
<li>The PC tool can now send one or more of below commands with the file data, one after the other, until it is done.<ul>
<li>Flash a file at a given offset in the flash</li>
<li>Verify a previously flashed file at a given offset in the flash</li>
<li>Erase a region of flash memory</li>
</ul>
</li>
<li>The flashing application as such does not care what the file contains, it will simply flash it at the user specified location.</li>
<li>However typically one needs to at least send the below files to flash<ul>
<li>Send a QSPI flash bootloader application and flash it at offset 0x0 (<code>sbl_qspi.release.tiimage</code>). If the QSPI bootloader is already flashed previously then this step can be skipped.</li>
<li>Send your application image multi-core image and flash it at offset 0x80000 (<code>*.mcelf</code>). The offset 0x80000 is the offset that is specified in the QSPI bootloader and when the EVM boots in QSPI mode, it will attempt to find a application at this location.</li>
</ul>
</li>
<li>After flashing is done, power OFF the EVM</li>
<li>Set EVM in QSPI boot mode and power ON the EVM.<ul>
<li>The ROM bootloader will now boot the QSPI bootloader by reading offset 0x0</li>
<li>And the QSPI bootloader will boot the application by reading from offset 0x80000.</li>
</ul>
</li>
<li>The initial flashing application and the subsequent commands to send and flash the QSPI bootloader and application files are all specified in a single configuration file which is provided as input to the tool.</li>
</ul>
<h2><a class="anchor" id="TOOLS_UART_UNIFLASH_GUI"></a>
GUI for UART Uniflash (Experimental)</h2>
<p>UART Uniflash GUI is a GUI wrapper around the UART Uniflash tool already present (<code>uart_uniflash.py</code>). This is a strictly experimental feature with minimal testing from TI side. Can be used if GUI is more comfortable. Since most of the CLI tool is used underneath, it is the same functionality wise</p>
<h3><a class="anchor" id="autotoc_md1355"></a>
Pre-Requisites for UART Uniflash GUI</h3>
<p>This GUI is built on top of the python based UART Uniflash CLI tool already mentioned, and specifically based on the PyQt5 binding of the QT5 framework. So it is expected that python3 and other dependencies (xmodem, pyserial etc) are already installed. In addition to this, one also needs to install the PyQt5 python library for the GUI to work.</p>
<ul>
<li><p class="startli">In windows, you can install PyQt5 by doing below:</p>
<p class="startli"><code>python -m pip install pyqt5</code></p>
</li>
<li><p class="startli">In Ubuntu (or other Debian based distros) you can install PyQt5 by doing below:</p>
<p class="startli"><code>sudo apt install python3-pyqt5</code></p>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md1356"></a>
Using the UART Uniflash GUI</h2>
<p>The UART Uniflash GUI can be used to flash files arbitrarily into the device flash</p>
<p> <style>div.image img[src="uniflash_gui_manual_config_sport.png"]{width:40%}</style> </p><div class="image">
<img src="uniflash_gui_manual_config_sport.png" alt=""/>
<div class="caption">
UART Uniflash GUI : Serial Port Selection</div></div>
<p>At the top there is a drop down to select the UART COM port which will be used for flashing. Please connect the target to the EVM before running the GUI so that the serial port we are interested will show up here.</p>
<ul>
<li>For choosing what to flash and how to flash there are two high level choices in UART Uniflash GUI:<ul>
<li>Manual Config</li>
<li>From File</li>
</ul>
</li>
</ul>
<p> <style>div.image img[src="uniflash_gui_manual_config.png"]{ width:50%}</style>  <style>div.image img[src="uniflash_gui_file_config.png"]{ width:50%}</style></p>
<table style="border: 0 px">
<tr>
<td><div class="image">
<img src="uniflash_gui_manual_config.png" alt=""/>
<div class="caption">
UART Uniflash GUI : Manual Config based flashing</div></div>
  </td><td><div class="image">
<img src="uniflash_gui_file_config.png" alt=""/>
<div class="caption">
UART Uniflash GUI : Config file based flashing</div></div>
   </td></tr>
</table>
<ul>
<li><b>Manual Config</b> : Manual configuration of the files to be flashed. There will be drop down file browse options to select the various files you will need to flash/send to the target. It provides options / slots to select below:<ul>
<li><b>Flash writer binary</b> : This is the sbl_uart_uniflash binary. This needs to be send first for the ROM to receive and boot. Once this boots up you can send any number of files arbitrarily for flashing.</li>
<li><b>Bootloader binary</b> : It is assumed that the eventual goal of the flashing process is to boot your application from the flash device. For this a bootloader capable of reading an image from flash device needs to be flashed at offset 0 (generally) of the flash. This would be the <code>sbl_ospi</code> or <code>sbl_qspi</code>. Although this is no different than flashing any other file to a particular offset, we have decided to keep it a separate option for better clarity. Although the offset is almost always 0, we have provided an offset edit box as well if there is any change whatsoever.</li>
<li><b>Application binary</b> : You can select the application image to be flashed from this slot. SDK convention is to flash at a 512 KB offset (0x80000). This can be changed, but keep in mind that the bootloader booting this application should be aware of this offset as well. It is a configurable option in the Sysconfig of the bootloader.</li>
<li><b>Custom data</b> : This slot can be used to flash any custom data file at an arbitrary offset. Don't forget to provide the offset</li>
<li><b>Flash PHY tuning data</b> : In certain NOR SPI drivers, for tuning the PHY, known data needs to be present in the flash. This is a fixed size (usually 128 bytes) array written to the last block of the flash. This check box needs to be ticked if you're flashing for the first time to the target so that this known data can be written to the flash.</li>
</ul>
</li>
</ul>
<p> <style>div.image img[src="uniflash_gui_manual_config_flash_phy_tuning.png"]{width:40%}</style> </p><div class="image">
<img src="uniflash_gui_manual_config_flash_phy_tuning.png" alt=""/>
<div class="caption">
UART Uniflash GUI : Saving the manual configuration</div></div>
<ul>
<li>There is an option to save the settings you selected manually as a config file using the <b>Save CFG</b> button towards the bottom right of the Manual Config group.</li>
</ul>
<p> <style>div.image img[src="uniflash_gui_manual_config_save_cfg.png"]{width:40%}</style> </p><div class="image">
<img src="uniflash_gui_manual_config_save_cfg.png" alt=""/>
<div class="caption">
UART Uniflash GUI : Saving the manual configuration</div></div>
<ul>
<li><b>From File</b> : Flash using a configuration file (<code>*.cfg</code> extension) specifying what needs to be flashed. This is a convenient option if the files to be flashed are pretty much the same for every try. In fact even in the manual config case, a cfg file is created internally and used for flashing. This <code>cfg</code> follows the same format used by the CLI script.</li>
</ul>
<p>After selecting the config options and files, just press the <b>FLASH</b> button to start the flashing. A progress bar will show the flashing progress.</p>
<p>There is also a log area which will show detailed logs in addition to the pop up messages.</p>
<p> <style>div.image img[src="uniflash_gui_manual_config_log_area.png"]{width:40%}</style> </p><div class="image">
<img src="uniflash_gui_manual_config_log_area.png" alt=""/>
<div class="caption">
UART Uniflash GUI : LOGS</div></div>
<h2><a class="anchor" id="autotoc_md1357"></a>
Important Notes and Common Pitfalls in UART Uniflash GUI</h2>
<ul>
<li>Make sure that the target device is powered ON and is in UART boot mode before attempting to flash</li>
<li>Make sure that the correct COM port is selected from the drop down. If the wrong port is selected, the flasher might take time to exit out as it will wait for the device to send the XMODEM control character.</li>
<li>If the GUI seems to hang, re-check the selected COM port and make sure the EVM is <b>powered ON</b> and in <b>UART boot mode</b></li>
<li>The GUI is based on the <code>uart_uniflash.py</code> CLI script, and reuses a lot of objects and functions, so core functionality is the same among both.</li>
<li>In manual config case, if a drop down is non blank it is assumed that the file provided there needs to be flashed. So it will be picked up and used when <code>FLASH</code> button is clicked. If this is not required, make sure to delete it and keep it blank, the drop down is editable. This is true for the config file drop down as well, but the mishap is more probable in manual config case.</li>
</ul>
<h1><a class="anchor" id="TOOLS_FLASH_JTAG_UNIFLASH"></a>
JTAG Uniflash</h1>
<ul>
<li>JTAG(Joint Test Action Group) is used as the transport or interface to send the file to flash to the EVM.</li>
<li>It uses a serial protocol to communicate with the DAP (Debug Access Port) on the EVM.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1358"></a>
Sequence of steps that happen when flashing via JTAG</h2>
<ul>
<li>Debugger initializes the SOC<ul>
<li>CCS connects using the JTAG interface and uses gel scripts to initialize PLLs, clocks and memory.</li>
</ul>
</li>
<li>Flash driver gets loaded into RAM<ul>
<li>A flash programming algorithm is loaded into RAM via JTAG.</li>
<li>This algorithm contains a program that can write to the flash memory.</li>
</ul>
</li>
<li>Then your binary (.mcelf/.tiimage) is streamed over the JTAG. The driver receives chunks of the application, unlocks the target flash memory regions, erases the sectors and performs flash write operation.</li>
<li>Once the JTAG has successfully received the SBL and application binaries, switch to QSPI bootmode and reset the board.</li>
<li>ROM bootloader will boot the flashed SBL(secondary bootloader) and the SBL will boot up the application.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1359"></a>
Important files and folders</h2>
<table class="doxtable">
<tr>
<th>Folder/Files </th><th>Description  </th></tr>
<tr>
<td colspan="2" bgcolor="#F0F0F0">${SDK_INSTALL_PATH}/examples/drivers/boot/ </td></tr>
<tr>
<td>sbl_jtag_uniflash </td><td>Flash-writer example which uses JTAG to write files or erase flash  </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md1360"></a>
Basic steps to flash files</h2>
<p>Refer the example <a class="el" href="EXAMPLES_DRIVERS_SBL_JTAG_UNIFLASH.html">SBL JTAG Uniflash</a></p>
<h1><a class="anchor" id="TOOLS_FLASH_CAN_UNIFLASH"></a>
CAN Uniflash</h1>
<p>CAN is used as the transport or interface to send the file to flash to the EVM. </p>
<h2><a class="anchor" id="autotoc_md1361"></a>
Important files and folders</h2>
<table class="doxtable">
<tr>
<th>Folder/Files </th><th>Description  </th></tr>
<tr>
<td colspan="2" bgcolor="#F0F0F0">${SDK_INSTALL_PATH}/examples/drivers/boot/ </td></tr>
<tr>
<td>sbl_can_uniflash </td><td>Flash-writer example which uses CAN to write files  </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md1362"></a>
Basic steps to flash files</h2>
<p>Refer the example <a class="el" href="EXAMPLES_DRIVERS_SBL_CAN_UNIFLASH.html">SBL CAN UNIFLASH</a></p>
<h1><a class="anchor" id="TOOLS_FLASH_ENET_UNIFLASH"></a>
ENET Uniflash</h1>
<p>UDP over ethernet is used as the transport or interface to send the file to flash to the EVM.</p>
<h2><a class="anchor" id="autotoc_md1363"></a>
Tool requirements on host PC</h2>
<ul>
<li>The tool is implemented using python and needs python version 3.x</li>
<li>The tool uses additional python packages as listed below.<ul>
<li>tqdm for progress bar when the tool is run</li>
</ul>
</li>
<li>Refer to the page, <a class="el" href="SDK_DOWNLOAD_PAGE.html#INSTALL_PYTHON3">Python3</a> , to install python and the required python packages on your PC.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1364"></a>
Important files and folders</h2>
<table class="doxtable">
<tr>
<th>Folder/Files </th><th>Description  </th></tr>
<tr>
<td colspan="2" bgcolor="#F0F0F0">${SDK_INSTALL_PATH}/tools/boot/ </td></tr>
<tr>
<td>enet_uniflash.py </td><td>Flashing tool  </td></tr>
<tr>
<td>sbl_prebuilt/am263x-cc </td><td>Pre-built bootloader images and default flash configuration files for a supported EVM  </td></tr>
<tr>
<td colspan="2" bgcolor="#F0F0F0">${SDK_INSTALL_PATH}/examples/drivers/boot/ </td></tr>
<tr>
<td>sbl_qspi_enet </td><td>QSPI bootloader application and Flashing application that is run on the EVM to receive files to flash. To be flashed at offset 0x0. When in QSPI boot mode, this bootloader application will boot the user application file for all the CPUs  </td></tr>
</table>
<h2><a class="anchor" id="BASIC_STEPS_TO_FLASH_FILES_OVER_ENET"></a>
Basic steps to flash files over ethernet</h2>
<h3><a class="anchor" id="autotoc_md1365"></a>
Getting ready to flash</h3>
<ul>
<li>Make sure the QSPI Ethernet bootloader (<code>sbl_qspi_enet</code>) has been flashed using the steps provided in <a class="el" href="TOOLS_FLASH.html#BASIC_STEPS_TO_FLASH_FILES">Basic steps to flash files</a>.</li>
<li>Make sure the user application (<code>*.appimage</code>) you want to flash over ethernet is built for the EVM.</li>
</ul>
<h3><a class="anchor" id="autotoc_md1366"></a>
Flash configuration file</h3>
<ul>
<li>Create a flash configuration file, using the default flash configuration file present <pre class="fragment">  ${SDK_INSTALL_PATH}/tools/boot/sbl_prebuilt/{board}/default_sbl_qspi.cfg
</pre></li>
<li><p class="startli">In this config file, modify the paths to the application to be flashed only.</p>
<p class="startli">Remove or comment out the flash-writer path </p><pre class="fragment"> --flash-writer={path to flash application .tiimage}
</pre><p class="startli">Remove or comment out the bootloader path </p><pre class="fragment"> --file={path to QSPI bootloader .tiimage} --operation=flash --flash-offset=0x0
</pre><p class="startli">Edit below line to point to the user application (<code>.appimage</code>) file </p><pre class="fragment"> --file={path to your application .appimage file} --operation=flash --flash-offset=0xA0000
</pre></li>
</ul>
<h3><a class="anchor" id="autotoc_md1367"></a>
Flashing the files over ethernet</h3>
<ul>
<li>Run below python command on the Windows command prompt (<code>cmd.exe</code>) or Linux bash shell to flash the files. <pre class="fragment">  cd ${SDK_INSTALL_PATH}/tools/boot
  python enet_uniflash.py --cfg={path to your edited config file}
</pre></li>
<li><p class="startli">When the python script starts, it will display the message "Starting Linkup ...".</p>
<p class="startli">Based on the MACRO ENETSBL_TRANSFER_START_MODE set in sbl_enet.h of the sbl_qspi_enet bootloader, do either of the below when the above message is observed,</p><ul>
<li>If in ENETSBL_TIMER_MODE, Press the reset button SW1 on the EVM.</li>
<li>If in ENETSBL_BUTTON_MODE, Press the reset button SW1 while holding down the user switch SW2.</li>
</ul>
</li>
<li>After flashing is successful, the flashed application code will be automatically run after the SBL completes. See <a class="el" href="EXAMPLES_DRIVERS_SBL_QSPI_ENET_AM263X.html#SBL_QSPI_ENET_OUTPUT_SAMPLE">Sample Output</a> for a sample of the python script output after a successful flash.</li>
</ul>
<h3><a class="anchor" id="autotoc_md1368"></a>
Flash tool options</h3>
<ul>
<li>Type below to see all the possible options with the flashing tool and also see the default .cfg file for syntax and options possible in the config file <pre class="fragment">  cd ${SDK_INSTALL_PATH}/tools/boot
  python enet_uniflash.py --help
</pre> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
