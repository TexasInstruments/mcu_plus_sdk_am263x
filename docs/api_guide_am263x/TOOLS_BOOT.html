<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<title>AM263x MCU+ SDK: Booting Tools</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="AM263x MCU+ SDK"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AM263x MCU+ SDK
   &#160;<span id="projectnumber">11.00.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.html" method="get">
              <img id="MSearchSelect" src="search/mag.svg" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('TOOLS_BOOT.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Booting Tools </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md1369">Introduction</a></li>
<li class="level1"><a href="#autotoc_md1370">Important files and folders</a></li>
<li class="level1"><a href="#MCELF_GEN_TOOL">MCELF Image Gen</a></li>
<li class="level1"><a href="#UART_BOOTLOADER_PYTHON_SCRIPT">UART Bootloader Python Script</a></li>
<li class="level1"><a href="#SOC_ID_PARSER">SoC ID parser Python Script</a></li>
<li class="level1"><a href="#CAN_BOOTLOADER_PYTHON_SCRIPT">CAN Bootloader Python Script</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_components_tools_tools_boot"></a></p>
<dl class="section note"><dt>Note</dt><dd>To see the exact sequence of steps in which applications and secondary bootloader (SBL) are converted from compiler generated .out files to boot images, see the makefile <code>makefile_ccs_bootimage_gen</code> that is included in every example and secondary bootloader (SBL) CCS project.</dd>
<dd>
If you are using makefile based build, then see the file named <code>makefile</code> in the example folder.</dd></dl>
<h1><a class="anchor" id="autotoc_md1369"></a>
Introduction</h1>
<p>This section describes the various tools that are used to create boot images for all the SDK applications</p>
<h1><a class="anchor" id="autotoc_md1370"></a>
Important files and folders</h1>
<table class="doxtable">
<tr>
<th>Folder/Files </th><th>Description  </th></tr>
<tr>
<td colspan="2" bgcolor="#F0F0F0"><p class="starttd">${SDK_INSTALL_PATH}/tools/boot/</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>sbl_prebuilt/ </td><td>Pre-built secondary bootloader (SBL) images and flash configuration files for different supported EVMs, see also <a class="el" href="TOOLS_FLASH.html">Flashing Tools</a>  </td></tr>
<tr>
<td>signing/ </td><td><p class="starttd">Security signing scripts need to create boot images that can be booted by ROM bootloader (RBL) </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>uart_bootloader.py </td><td>Python script used to send the SBL and application binaries over UART using XMODEM protocol in UART boot mode  </td></tr>
<tr>
<td>uart_uniflash.py </td><td><p class="starttd">Python script used to flash SBL and applications to EVM flash using UART. See <a class="el" href="TOOLS_FLASH.html">Flashing Tools</a> for more details. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>genimage.py </td><td><p class="starttd">Python script used to generate multicore elf image from individual core elf images. </p>
<p class="endtd"></p>
</td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>RPRC tools (Out2RPRC and Multi-core Image Gen) has been deprecated from SDK 11.00 release onwards. MCELF would be the default application format.</dd></dl>
<h1><a class="anchor" id="MCELF_GEN_TOOL"></a>
MCELF Image Gen</h1>
<ul>
<li>This tool takes individual core ELF files as input and combines their segments to create a single ELF file.</li>
<li>Shown below is the file format for an mcelf image file and its metacontent as seen by <code>readelf</code></li>
</ul>
<p> <style>div.image img[src="tools_mcelf_format.png"]{width:60%}</style> </p><div class="image">
<img src="tools_mcelf_format.png" alt=""/>
<div class="caption">
MCELF Image File Format</div></div>
<ul>
<li>Segment data from each input ELF file is extracted and appended together to form a single list of segments.</li>
<li>The program header table fields are then re-calculated and the header table is regenerated using information from this new segment list.</li>
<li>Once that is done, from the updated program header, the ELF header is regenerated.</li>
<li>The first segment is the note segment. It can be customized to store information according to your application. By default the note segment contains vendor information, segment to core mapping and entry points.</li>
<li>The segment sizes can be manipulated using appropriate arguments.</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>--core-img</code>  </td><td class="markdownTableBodyNone">Path to individual binaries of each core. It is a mandatory argument. Input is given in this format: <code>--core-img=0:&lt;core0_binary.out&gt; --core-img=1:&lt;core1_binary.out&gt;</code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>--output</code>  </td><td class="markdownTableBodyNone">The output file name. It is a mandatory argument. <code>--output=&lt;file_name&gt;.mcelf</code>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>--merge-segments</code>  </td><td class="markdownTableBodyNone">Enable merging segments based on a tolerance limit. Default value is false.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>--tolerance-limit</code>  </td><td class="markdownTableBodyNone">The maximum difference (in bytes) between the end address of previous segment and start address of current segment for merging the segments. Default value is zero.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>--ignore-context</code>  </td><td class="markdownTableBodyNone">Enable merging of segments that are of different cores. Default value is false.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>--xip</code>  </td><td class="markdownTableBodyNone">XIP section's start and end address seperated by a colon. It creates a new file <code>&lt;filename&gt;.mcelf_xip</code>. It is a mandatory argument. In case of no XIP regions, use <code>--xip=None</code> (XIP is disabled even though file exists). Argument format when XIP region exists: <code>--xip=0x60100000:0x60200000</code>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>--max-segment-size</code>  </td><td class="markdownTableBodyNone">Maximum allowed size of a loadable segment. This feature can only be used with merge_segments disabled. Default value is 8192 bytes.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>--xlat</code>  </td><td class="markdownTableBodyNone">SOC specific Address Translation. (Under development, reserved for future use)   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>--sso</code>  </td><td class="markdownTableBodyNone">Path to SSO binary file. Default value is None.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>--otfaConfigFile</code>  </td><td class="markdownTableBodyNone">Path to JSON file containing the OTFA config. Disabled by default with value None.   </td></tr>
</table>
<ul>
<li>The input for arguments 3-8 are defined in {MCU_SDK_PATH}/devconfig/devconfig.mak file.</li>
<li>Given below are the structs used in the bootloader library to parse a 32 bit MCELF binary</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#define E_IDENT 16</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* ELF HEADER */</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>Bootloader_ELFH32_s</div>
<div class="line">{</div>
<div class="line">    uint8_t  e_ident[E_IDENT];</div>
<div class="line">    uint16_t e_type;</div>
<div class="line">    uint16_t e_machine;</div>
<div class="line">    uint32_t e_version;</div>
<div class="line">    uint32_t e_entry;</div>
<div class="line">    uint32_t e_phoff;</div>
<div class="line">    uint32_t e_shoff;</div>
<div class="line">    uint32_t e_flags;</div>
<div class="line">    uint16_t e_ehsize;</div>
<div class="line">    uint16_t e_phentsize;</div>
<div class="line">    uint16_t e_phnum;</div>
<div class="line">    uint16_t e_shentsize;</div>
<div class="line">    uint16_t e_shnum;</div>
<div class="line">    uint16_t e_shstrndx;</div>
<div class="line"> </div>
<div class="line">} Bootloader_ELFH32;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* PROGRAM HEADER */</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>Bootloader_ELFPH32_s</div>
<div class="line">{</div>
<div class="line">    uint32_t type;</div>
<div class="line">    uint32_t offset;</div>
<div class="line">    uint32_t vaddr;</div>
<div class="line">    uint32_t paddr;</div>
<div class="line">    uint32_t filesz;</div>
<div class="line">    uint32_t memsz;</div>
<div class="line">    uint32_t <a class="code" href="hsmclient__msg_8h.html#aa2585d779da0ab21273a8d92de9a0ebe">flags</a>;</div>
<div class="line">    uint32_t align;</div>
<div class="line"> </div>
<div class="line">} Bootloader_ELFPH32;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* NOTE SEGMENT */</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>Bootloader_ELFNote_s</div>
<div class="line">{</div>
<div class="line">    uint32_t namesz;</div>
<div class="line">    uint32_t descsz;</div>
<div class="line">    uint32_t type;</div>
<div class="line">} Bootloader_ELFNote;</div>
</div><!-- fragment --><ul>
<li>Use the following command to invoke this script to generate a basic <code>.mcelf</code> image from input <code>.out</code> files without any segment manipulations</li>
</ul>
<div class="fragment"><div class="line">$ cd tools/boot/multicore-elf</div>
<div class="line"> </div>
<div class="line">$ pip install -r requirements.txt</div>
<div class="line"> </div>
<div class="line">$ {PYTHON} genimage.py --core-img={CORE_0_ID}:{core0_app.out} --core-img={CORE_1_ID}:{core1_app.out} --core-img={CORE_2_ID}:{core2_app.out} --core-img={CORE_3_ID}:{core3_app.out} --output={application.mcelf} </div>
</div><!-- fragment --><ul>
<li>The various core ID to be used are as below.</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">CORE  </th><th class="markdownTableHeadNone">CORE ID   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">r5fss0-0  </td><td class="markdownTableBodyNone">0   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">r5fss0-1  </td><td class="markdownTableBodyNone">1   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">r5fss1-0  </td><td class="markdownTableBodyNone">2   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">r5fss1-1  </td><td class="markdownTableBodyNone">3   </td></tr>
</table>
<h1><a class="anchor" id="UART_BOOTLOADER_PYTHON_SCRIPT"></a>
UART Bootloader Python Script</h1>
<ul>
<li>This script is used in UART boot mode for sending the SBL and application binaries to the EVM via UART using XMODEM protocol</li>
<li>Make sure that python3 and its dependent modules are installed in the host machine as mentioned in <a class="el" href="SDK_DOWNLOAD_PAGE.html#INSTALL_PYTHON3">Python3</a></li>
<li>Booting via UART is slow, but is useful if application loading via CCS or OSPI boot is not an option</li>
<li>Make sure the UART port used for terminal is identified as mentioned in <a class="el" href="EVM_SETUP_PAGE.html#CCS_UART_TERMINAL">Setup UART Terminal</a></li>
<li>Make sure you have the EVM power cable and UART cable connected as shown in <a class="el" href="EVM_SETUP_PAGE.html#EVM_CABLES">Cable Connections</a></li>
<li>To boot applications using this script, <b>POWER OFF the EVM</b></li>
<li>Switch to <a class="el" href="EVM_SETUP_PAGE.html#BOOTMODE_UART">UART BOOT MODE</a>.</li>
<li><b>POWER ON the EVM</b></li>
<li>To confirm that the board is in UART boot mode, open the UART terminal and confirm that you see the character 'C' getting printed on the console every 2-3 seconds.</li>
<li>Now close the terminal. This is important as the script won't be able to function properly if the UART terminal is open.</li>
<li>Open a command prompt and run the below command to send the SBL and application binary to the EVM <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot</div>
<div class="line">python uart_bootloader.py -p COM&lt;x&gt; --bootloader=sbl_prebuilt/{board}/sbl_uart.release.tiimage --file=&lt; path to multicore application binary &gt;</div>
</div><!-- fragment --><ul>
<li>When you execute this, the script first sends the uart bootloader, and then the multicore application</li>
</ul>
</li>
<li>After the multicore application file is successfully parsed, the uart bootloader sends an acknowledgment to the script and waits for 5 seconds before running the application binary</li>
<li>Upon receiving the ack, the script will exit successfully</li>
<li>Connect to the UART terminal within 5 seconds to see logs from the application</li>
<li>Below are the logs of the script after all the files have been sent if (SOC_AM263X || SOC_AM263PX || SOC_AM261X) <div class="fragment"><div class="line">Sending the UART bootloader sbl_prebuilt/{board}/sbl_uart.release.tiimage ...</div>
<div class="line">Sent bootloader sbl_prebuilt/{board}/sbl_uart.release.tiimage of size 243975 bytes in 23.94s.</div>
<div class="line"> </div>
<div class="line">Sending the application ../../examples/drivers/udma/udma_memcpy_polling/{board}/r5fss0-0_nortos/ti-arm-clang/udma_memcpy_polling.release.mcelf ...</div>
<div class="line">Sent application ../../examples/drivers/udma/udma_memcpy_polling/{board}/r5fss0-0_nortos/ti-arm-clang/udma_memcpy_polling.release.mcelf of size 99580 bytes in 11.74s.</div>
<div class="line">[STATUS] Application load SUCCESS !!!</div>
<div class="line">Connect to UART in 2 seconds to see logs from UART !!!</div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="SOC_ID_PARSER"></a>
SoC ID parser Python Script</h1>
<ul>
<li>Boot ROM reports SoC ID on UART console of the device when UART boot mode is selected. It reports on both GP and HS devices and it provides insights into device configuration which would be helpful for debugs.</li>
<li>uart_boot_socid.py is a python3 based parser to convert the hexadecimal numbers reported by ROM to human readable text, below are the steps involved to use this parser. This will be helpful in debugging the device boot issue. This will also help to see important information about device like device type, prime/non-prime, key count, key revision, MPK hash etc.</li>
<li>Make sure python3 is installed as mentioned in <a class="el" href="SDK_DOWNLOAD_PAGE.html#INSTALL_PYTHON3">Python3</a></li>
<li><b>Steps to use the parser:</b><ul>
<li>Copy the soc id reported in UART console</li>
<li>pass the copied id to the script either as a plain string or saving it into a file</li>
<li>execute the script <div class="fragment"><div class="line">$python uart_boot_socid.py -d am64x --string=&lt;copied soc id&gt;</div>
<div class="line">or</div>
<div class="line">$python uart_boot_socid.py -d am64x --file=soc_id.txt</div>
</div><!-- fragment --></li>
</ul>
</li>
<li>Example Output: <div class="fragment"><div class="line">-----------------------</div>
<div class="line">SoC ID Header Info:</div>
<div class="line">-----------------------</div>
<div class="line">NumBlocks            : 2</div>
<div class="line">-----------------------</div>
<div class="line">SoC ID Public ROM Info:</div>
<div class="line">-----------------------</div>
<div class="line">SubBlockId           : 1</div>
<div class="line">SubBlockSize         : 26</div>
<div class="line">DeviceName           : am64x</div>
<div class="line">DeviceType           : HSSE</div>
<div class="line">DMSC ROM Version     : [0, 2, 0, 0]</div>
<div class="line">R5 ROM Version       : [0, 2, 0, 0]</div>
<div class="line">-----------------------</div>
<div class="line">SoC ID Secure ROM Info:</div>
<div class="line">-----------------------</div>
<div class="line">Sec SubBlockId       : 2</div>
<div class="line">Sec SubBlockSize     : 166</div>
<div class="line">Sec Prime            : 0</div>
<div class="line">Sec Key Revision     : 1</div>
<div class="line">Sec Key Count        : 1</div>
<div class="line">Sec TI MPK Hash      : b018658ad99dc903c8c9bfb27b12751099920a042ad1dfea7b7ba57369f15546de285edde6a7b39a8bdc40a27b237f8fb1e57f245e80b929c1e28b024aa2ecc6</div>
<div class="line">Sec Cust MPK Hash    : 1f6002b07cd9b0b7c47d9ca8d1aae57b8e8784a12f636b2b760d7d98a18f189760dfd0f23e2b0cb10ec7edc7c6edac3d9bdfefe0eddc3fff7fe9ad875195527d</div>
<div class="line">Sec Unique ID        : 01f22176afca3a82692ce53b2738b8c982f7538602871e0bdb7dc2f7668d04b2</div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="CAN_BOOTLOADER_PYTHON_SCRIPT"></a>
CAN Bootloader Python Script</h1>
<ul>
<li>This script is used in QSPI boot mode for sending the mcelf binaries to the EVM via CAN, after flashing the SBL CAN. Refer <a class="el" href="TOOLS_FLASH.html#BASIC_STEPS_TO_FLASH_FILES">Basic steps to flash files</a> for flashing.</li>
<li>Make sure that python3 and its dependent modules are installed in the host machine as mentioned in <a class="el" href="SDK_DOWNLOAD_PAGE.html#INSTALL_PYTHON3">Python3</a></li>
<li>Make sure the UART port used for terminal is identified as mentioned in <a class="el" href="EVM_SETUP_PAGE.html#CCS_UART_TERMINAL">Setup UART Terminal</a></li>
<li>Make sure you have the EVM power cable and CAN cable connected as shown in <a class="el" href="EXAMPLES_DRIVERS_SBL_CAN.html">SBL CAN</a></li>
<li>To boot applications using this script, <b>POWER OFF the EVM</b></li>
<li>Switch to <a class="el" href="EVM_SETUP_PAGE.html#BOOTMODE_QSPI">QSPI BOOT MODE</a></li>
<li><b>POWER ON the EVM</b></li>
<li>Open a command prompt and run the below command to send the application binary to the EVM <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot</div>
<div class="line">python can_bootloader.py --file=&lt; path to multicore mcelf application binary &gt;</div>
</div><!-- fragment --></li>
<li>When you execute this, the script first sends the multicore mcelf to the EVM</li>
<li>After the multicore mcelf is successfully parsed, the CAN bootloader sends an acknowledgment to the script</li>
<li>Upon receiving the ack, the script will exit successfully</li>
<li>Connect to the UART terminal to see logs from the application</li>
<li>Below are the logs of the script after all the files have been sent <div class="fragment"><div class="line">Sending the application ../../examples/drivers/udma/udma_memcpy_polling/{board}/r5fss0-0_nortos/ti-arm-clang/udma_memcpy_polling.release.mcelf ...</div>
<div class="line">Sent application ../../examples/drivers/udma/udma_memcpy_polling/{board}/r5fss0-0_nortos/ti-arm-clang/udma_memcpy_polling.release.mcelf of size 99580 bytes in 11.74s.</div>
<div class="line">[STATUS] BOOTLOADER_CAN_STATUS_LOAD_SUCCESS!!!</div>
<div class="line">Connect to UART to see logs from UART !!!</div>
</div><!-- fragment --> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="ahsmclient__msg_8h_html_aa2585d779da0ab21273a8d92de9a0ebe"><div class="ttname"><a href="hsmclient__msg_8h.html#aa2585d779da0ab21273a8d92de9a0ebe">flags</a></div><div class="ttdeci">uint8_t flags</div><div class="ttdef"><b>Definition:</b> hsmclient_msg.h:2</div></div>
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
