<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<title>AM263x MCU+ SDK: Understanding the bootflow and bootloaders</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="AM263x MCU+ SDK"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AM263x MCU+ SDK
   &#160;<span id="projectnumber">11.00.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.html" method="get">
              <img id="MSearchSelect" src="search/mag.svg" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('BOOTFLOW_GUIDE.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Understanding the bootflow and bootloaders </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md614">Introduction</a><ul><li class="level2"><a href="#autotoc_md615">What Is Bootloader?</a></li>
<li class="level2"><a href="#autotoc_md616">Multi-Stage Bootloader</a></li>
<li class="level2"><a href="#autotoc_md617">Multi-Core Bootloading</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md618">Bootloading in MCU+SDK</a><ul><li class="level2"><a href="#autotoc_md619">ROM Boot</a><ul><li class="level3"><a href="#autotoc_md620">Preparing the SBL for boot</a></li>
</ul>
</li>
<li class="level2"><a href="#BOOTFLOW_MCELF_BOOT">Booting MCELF application</a><ul><li class="level3"><a href="#autotoc_md621">Booting the application</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md622">Secure Boot</a></li>
<li class="level1"><a href="#autotoc_md623">PBIST For 200MHz and 400MHz R5F Core Variants</a></li>
<li class="level1"><a href="#autotoc_md624">Additional References</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_developer_guides_bootflow"></a></p>
<h1><a class="anchor" id="autotoc_md614"></a>
Introduction</h1>
<p>This section is aimed at explaining what a bootloader is, why is it needed and details regarding the bootloader and bootflow used in the MCU+SDK.</p>
<h2><a class="anchor" id="autotoc_md615"></a>
What Is Bootloader?</h2>
<p>Generally speaking, bootloader is a piece of software / firmware that runs as soon as you power on an SoC. A bootloader's main duty is to start the subsequent pieces of software, such an OS, a baremetal application or in some cases another bootloader. When it comes to embedded, the bootloader is usually closely tied with the underlying SoC architecture. The bootloader is usually stored in a protected, non-volatile on-chip memory. Typically the bootloader performs various hardware checks, initializes the processor and configures the SoC registers etc. Since the primary aim of the bootloader is to load the next piece of software, it needs to communicate to the external world to receive this firmware/application image. This can be over a number of protocols - USB, UART, SPI, I2C, External Flash, Internal Flash, SD Card, Ethernet, CAN etc. Bootloader is also a key component in embedded security. Hardware Root-of-Trust is usually passed onto the bootloader and is passed on down the line.</p>
<dl class="section note"><dt>Note</dt><dd>In devices supported by MCU+SDK, the first stage bootloader is burned into read-only memory of the device and is considered as device firmware / ROM. Mostly in MCU+SDK when we say "bootloader" we are referring to the secondary bootloader, or the SBL</dd></dl>
<h2><a class="anchor" id="autotoc_md616"></a>
Multi-Stage Bootloader</h2>
<p>As mentioned earlier, sometimes the bootloader would be loading another bootloader which can load another one and so on. This is usually the case in advanced SoCs, and there are various reasons for this. The first bootloader is usually kept on secure, read-only memory for security reasons and to have a known state always before application software starts. It makes sense then to keep this bootloader simple and let it do only the bare minimum configuration required. This secondary bootloader can be complex and configurable to suit the needs of the application. This can also be updated easily compared to the first stage bootloader. In fact for the devices in MCU+SDK, we have a two-stage bootloading - the first stage bootloader is called ROM Bootloader (RBL) and the second stage bootloader is called Secondary Bootloader (SBL).</p>
<h2><a class="anchor" id="autotoc_md617"></a>
Multi-Core Bootloading</h2>
<p>Multi-core bootloading is almost always a follow up when there is a multi-stage bootloading. In this case the first bootloader technically might not be even aware of the other cores, it will just boot the next stage bootloader and this second stage bootloader will take care of the complex bootloading on the different cores.</p>
<p>Loading a multi-core application is slightly more complicated than loading a single core application. There would be concerns regarding image preparation, shared memory access, and so on. Mostly there would be a particular format in which the individual core images are created, and then they may/may not be concatenated into a single image for SBL to load. Whatever format the application image is in, the SBL should be aware of it so that it can parse and load the image correctly.</p>
<h1><a class="anchor" id="autotoc_md618"></a>
Bootloading in MCU+SDK</h1>
<p>In the MCU+SDK, the bootflow takes place mainly in two steps after you power ON the device</p><ul>
<li><b>ROM boot</b>, in which the ROM bootloader boots a secondary bootloader or an SBL</li>
<li><b>SBL boot</b> in which the secondary bootloader boots the application</li>
</ul>
<h2><a class="anchor" id="autotoc_md619"></a>
ROM Boot</h2>
<p>The <b>RBL</b> or ROM Bootloader is stored in read-only memory and is almost considered as part of the SoC. The details regarding the RBL and ROM Boot is out of scope for this user guide. Please refer to the Technical Reference Manual of the device for more details. But basically the ROM expects an x509 signed binary image of the secondary bootloader to be provided for boot.</p>
<ul>
<li>As soon as the board is powered ON, the ROM bootloader or RBL starts running. The RBL is the primary bootloader.</li>
<li>Depending on which boot mode is selected, the RBL will load the <b>secondary bootloader</b> or SBL from a boot media (OSPI flash, SD card or via UART).</li>
<li>Rest of the booting is done by the SBL.</li>
<li>The RBL expects the image it boots (SBL in our case) to always be signed as mentioned above. Refer <a class="el" href="TOOLS_BOOT.html">Booting Tools</a> for more information on signing scripts.</li>
</ul>
<p>The x509 template for ROM looks something like this:</p>
<div class="fragment"><div class="line">[ req ]</div>
<div class="line">distinguished_name     = req_distinguished_name</div>
<div class="line">x509_extensions        = v3_ca</div>
<div class="line">prompt                 = no</div>
<div class="line"> </div>
<div class="line">dirstring_type = nobmp</div>
<div class="line"> </div>
<div class="line">[ req_distinguished_name ]</div>
<div class="line">C                      = US</div>
<div class="line">ST                     = SC</div>
<div class="line">L                      = New York</div>
<div class="line">O                      = Texas Instruments., Inc.</div>
<div class="line">OU                     = SITARA MCU</div>
<div class="line">CN                     = Albert</div>
<div class="line">emailAddress           = Albert@gt.ti.com</div>
<div class="line"> </div>
<div class="line">[ v3_ca ]</div>
<div class="line">basicConstraints = CA:true</div>
<div class="line">1.3.6.1.4.1.294.1.1=ASN1:SEQUENCE:boot_seq</div>
<div class="line">1.3.6.1.4.1.294.1.2=ASN1:SEQUENCE:image_integrity</div>
<div class="line">1.3.6.1.4.1.294.1.3=ASN1:SEQUENCE:swrv</div>
<div class="line"> </div>
<div class="line">[ boot_seq ]</div>
<div class="line">certType     =  INTEGER:1</div>
<div class="line">bootCore     =  INTEGER:16</div>
<div class="line">bootCoreOpts =  INTEGER:0</div>
<div class="line">destAddr     =  FORMAT:HEX,OCT:70002000</div>
<div class="line">imageSize    =  INTEGER:199488</div>
<div class="line"> </div>
<div class="line">[ image_integrity ]</div>
<div class="line">shaType = OID:2.16.840.1.101.3.4.2.3</div>
<div class="line">shaValue = FORMAT:HEX,OCT:1d1b24e6487709f007d87c8b2b593abf1853a82a99a54650de85f40ddc7b5ae4558a68e49ea3668732ea34ff4bcf76cc73e4e354a3b8128726843c71b05c4168</div>
<div class="line"> </div>
<div class="line">[ swrv ]</div>
<div class="line">swrv = INTEGER:1</div>
</div><!-- fragment --><p>Depending on the device type, these are the validation requirements for ROM:</p>
<p> <style>div.image img[src="device_types_validation_req_am263x.png"]{width:50%}</style> </p><div class="image">
<img src="device_types_validation_req_am263x.png" alt=""/>
<div class="caption">
Validation for Device Types</div></div>
<ul>
<li>For ROM to accept any image to boot, there are some restrictions in the image preparation</li>
</ul>
<h3><a class="anchor" id="autotoc_md620"></a>
Preparing the SBL for boot</h3>
<p>The SBL is like any other application, created using the same compiler and linker toolchain. It is an example implementation rather than a deliverable. It is customizable by users, but must adhere to the requirements by RBL which is a constant as mentioned above. However the steps to convert the application <code>.out</code> into a bootable image are different for SBL as listed below:</p>
<ul>
<li>Other special factors for SBL application are listed below<ul>
<li>The linker command file for SBL has to place vectors at address <code>0x70002000</code> and this is the entry point for the SBL.</li>
<li>Nothing should be placed in ATCM or BTCM</li>
<li>Currently, the region 0x70002000 to 0x70040000 is used by the SBL code, data, stack, etc.</li>
</ul>
</li>
<li>After building, the SBL application <code>.out</code> file is first converted to a binary format <code>.bin</code> using the TI ARM CLANG <code>objcopy</code> tool.<ul>
<li>This copies the loadable sections from the .out into a binary image stripping all symbol and section information.</li>
<li>If there are two loadable sections in the image which are not contiguous then <code>objcopy</code> fills the gaps with <code>0x00</code>.</li>
<li>It is highly recommended to keep all loadable sections together within a SBL application.</li>
</ul>
</li>
<li>This <code>.bin</code> file is then signed using the <a class="el" href="TOOLS_SECURITY.html#TOOLS_BOOT_SIGNING">Signing Scripts</a> to create the final <code>.tiimage</code> bootable image.<ul>
<li>The <code>.tiimage</code> file extension is kept to separate the SBL boot image from a normal application image</li>
</ul>
</li>
<li>Refer <a class="el" href="BUILDING_APPLICATION.html#SBL_SIGNING">SBL Signing</a> for details on signing SBL image.</li>
</ul>
<h2><a class="anchor" id="BOOTFLOW_MCELF_BOOT"></a>
Booting MCELF application</h2>
<ul>
<li>In this case, SBL looks for the <b>multicore elf</b> image (refer <a class="el" href="TOOLS_BOOT.html">Booting Tools</a> for more on multicore elf image) of the application binary at a specified location in a boot media.</li>
<li>If the mcelf file is found, it is parsed into multiple <b>loadable segments</b>. These are then loaded into individual CPUs.</li>
<li>The <b>Note segment</b> of the MCELF image will have information regarding the core on which each segment that application binary needs to be loaded</li>
<li>The SBL uses this information to initialize each core, loads the segments to specified addresses, and then releases the core from reset. Now the core will start running.</li>
</ul>
<p> <style>div.image img[src="mcelf_sbl_boot.png"]{width:70%}</style> </p><div class="image">
<img src="mcelf_sbl_boot.png" alt=""/>
<div class="caption">
SBL Boot for MCELF</div></div>
<p>Now, as mentioned above, to boot an application with SBL it has to be specially prepared. Refer here <a class="el" href="BUILDING_APPLICATION.html">Building an Application</a> to see how an application is prepared to be bootable.</p>
<h3><a class="anchor" id="autotoc_md621"></a>
Booting the application</h3>
<p>After a SBL and application image is flashed, shown below is the high level boot flow, after the SOC is powered on.</p>
<p> <style>div.image img[src="bootflow_main.png"]{width:40%}</style> </p><div class="image">
<img src="bootflow_main.png" alt=""/>
<div class="caption">
HIGH LEVEL BOOTFLOW</div></div>
<h1><a class="anchor" id="autotoc_md622"></a>
Secure Boot</h1>
<p>In secure device variants, there are slight differences in the bootflow. For details on secure boot, please refer <a class="el" href="SECURE_BOOT.html">Enabling Secure Boot</a></p>
<h1><a class="anchor" id="autotoc_md623"></a>
PBIST For 200MHz and 400MHz R5F Core Variants</h1>
<p>pBIST (parallel Built-In Self-Test) can be performed for both 200MHz and 400MHz part numbers by including the instance of <code>mcu_bist</code> in the sys-config for the bootloader examples. By default it's enabled only for bootloader <code>sbl-sd</code>. For 400 MHz part numbers ROM performs pBIST on R5FSS0 Memories and L2 Memory - Bank-0 and Bank-1. But due to ROM limitation this test is not done by ROM for 200 MHz part numbers. The <code>mcu_bist</code> instance can be added or removed on the basis of use-case. pBIST is perfromed only on L2 memory - three banks (Bank-1,Bank-2,Bank3 (not on Bank-0)) and R5FSS1 TCM Memories. Please refer below for more information.</p>
<dl class="section note"><dt>Note</dt><dd>Important Information:<br  />
<ul>
<li>pBIST is a destructive test and cannot be run on active memories.<br  />
</li>
<li>Perform pBIST on specific sections of RAM and Subsystem 1 TCM, excluding active areas.<br  />
</li>
<li>SBL code must resides in the 0th bank of L2 memory to perform pBIST on the other three banks, as <code>mcu_bist</code> instance will run pBIST on L2 memory - Bank 1, Bank 2, Bank 3. The <code>mcu_bist</code> instance can be added for <code>sbl_qspi</code> as it resides in Bank-0. If SBL resides in banks other than Bank-0, the pBIST setup must be updated with the specific memories.<br  />
 </li>
</ul>
</dd></dl>
<table class="doxtable">
<tr>
<th>Step </th><th>Description  </th></tr>
<tr>
<td>1 </td><td>SBL Startup<br  />
 <ul>
<li>
Ensure SBL is installed correctly on the target device </li>
<li>
Power on or reset the device to initiate SBL startup </li>
</ul>
</td></tr>
<tr>
<td>2 </td><td>Efuse Bit Detection<br  />
 <ul>
<li>
During SBL startup, efuse bits will be checked </li>
<li>
If 200 MHz variant is detected, proceed to Step 3 </li>
<li>
Otherwise, skip to the next startup process </li>
</ul>
</td></tr>
<tr>
<td>3 </td><td>pBIST Execution<br  />
 <ul>
<li>
Initiating pBIST if 200 MHz variant is detected </li>
<li>
pBIST performed on specific sections of RAM and Subsystem 1 TCM memories, excluding active areas i.e., Subsystem 0 TCM memories </li>
<li>
SBL code resides in the 1st bank of L2 memory (Bank-0); So pBIST is performed on the other three banks of L2 memories. </li>
</ul>
</td></tr>
</table>
<p>In software workaround, pBIST is perfromed only on L2 memory - three banks (Bank-1,Bank-2,Bank3 (and not on Bank-0)) and R5FSS1 TCM Memories. <br  />
 User can perfrom pBIST on the remaining L2 Memory bank-0 and R5FSS0 TCM memories on their own by following the steps given below: The following table provides an overview of the steps to perform pBIST on RFSS0 TCM and L2 Memory Bank-0:</p>
<table class="doxtable">
<tr>
<th>Step </th><th>Description  </th></tr>
<tr>
<td>1 </td><td>Use the SDL example of pBIST that utilizes the SDL pBIST library.  </td></tr>
<tr>
<td>2 </td><td>Set up the test environment to specify L2 bank-0 and R5FSS0 TCM memories.  </td></tr>
<tr>
<td>3 </td><td>Update the SBL to be loaded on other memory banks (excluding bank 0).  </td></tr>
<tr>
<td>4 </td><td>The SBL will load the application on the RFSS1 core, which will run pBIST on the remaining L2 bank-0 and R5FSS0 TCM memories.  </td></tr>
<tr>
<td>5 </td><td>Once pBIST is completed, the device will be reset to proceed with normal booting.  </td></tr>
</table>
<p>By following these steps, you can perform pBIST on the specified L2 memory bank-0 and R5FSS0 TCM memories, ensuring proper self-testing, and allowing the device to boot normally afterwards.</p>
<p>• The pBIST can be run for both 200 MHz and 400 MHz part variants. To run the pBIST user can include <code>mcu_bist</code> instance for the specific bootloader in the syscfg. <br  />
• By default it's enabled only for bootloader <code>sbl-null</code>. <br  />
• The software workaround described in this user guide for L2 Memory Bank-0 and R5FSS0 TCM memories is specifically designed to address the ROM errata affecting 200 MHz R5F core variants. <br  />
• The pBIST procedure performed during the SBL startup helps mitigate the limitations imposed by the ROM. <br  />
• It is important to ensure that the SBL and associated software are correctly installed and configured on the target device for the workaround to function effectively.</p>
<p>To know more about pBIST and overall SDL support for pBIST, please take a look at <a class="el" href="SDL_PBIST_PAGE.html">PBIST</a></p>
<h1><a class="anchor" id="autotoc_md624"></a>
Additional References</h1>
<p>See also these additional pages for more details and examples about the boot flow,</p>
<ul>
<li>To understand different secondary bootloader (SBL) examples see,<ul>
<li><a class="el" href="EXAMPLES_DRIVERS_SBL_NULL.html">SBL NULL</a></li>
<li><a class="el" href="EXAMPLES_DRIVERS_SBL_UART_UNIFLASH.html">SBL UART Flash Writer</a></li>
<li><a class="el" href="EXAMPLES_DRIVERS_SBL_QSPI.html">SBL QSPI</a></li>
<li><a class="el" href="EXAMPLES_DRIVERS_SBL_UART.html">SBL UART</a></li>
<li><a class="el" href="EXAMPLES_DRIVERS_SBL_CAN.html">SBL CAN</a></li>
</ul>
</li>
<li>To understand the flashing steps, see <a class="el" href="TOOLS_FLASH.html">Flashing Tools</a></li>
<li>To understand the boot image creation tools, see <a class="el" href="TOOLS_BOOT.html">Booting Tools</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
