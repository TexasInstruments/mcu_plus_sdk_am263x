<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<title>AM263x MCU+ SDK: Ethernet PHY Driver User Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="AM263x MCU+ SDK"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AM263x MCU+ SDK
   &#160;<span id="projectnumber">11.00.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.html" method="get">
              <img id="MSearchSelect" src="search/mag.svg" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('enetphy_guide_top.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Ethernet PHY Driver User Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#enetphy_guide_intro">Introduction</a></li>
<li class="level1"><a href="#enetphy_guide_driver">PHY Driver</a><ul><li class="level2"><a href="#enetphy_guide_device_specific">Device-Specific Drivers</a></li>
</ul>
</li>
<li class="level1"><a href="#CustomBoardPhySupport">Custom Board Support</a><ul><ul><li class="level3"><a href="#autotoc_md1404">Board config C file</a></li>
</ul>
<li class="level2"><a href="#enetphy_guide_binding">PHY to Driver Binding</a></li>
</ul>
</li>
<li class="level1"><a href="#enetphy_guide_implementing">Implementing a New PHY Driver</a></li>
<li class="level1"><a href="#mac_to_mac_mode">MAC2MAC feature (NO-PHY mode)</a></li>
<li class="level1"><a href="#enetphy_guide_appendix">Appendix</a><ul><li class="level2"><a href="#enetphy_guide_appendix_a">Appendix A</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_components_networking_enet_lld_phy_integration"></a></p>
<h1><a class="anchor" id="enetphy_guide_intro"></a>
Introduction</h1>
<p>The Ethernet PHY driver is currently part of the Enet low-level driver (LLD), it's dedicated to Ethernet PHY management. It implements a state machine required to handle the lifecycle of PHYs, from initialization to link establishment.</p>
<p>The PHY submodule interacts with an underlying MDIO hardware through a simple MDIO driver abstraction (see <a class="el" href="structEnetPhy__Mdio.html">EnetPhy_Mdio</a>) in order to perform operations like detecting alive and/or linked PHYs, and for PHY register accesses. The relationship between PHY, MDIO and Enet LLD integration layer is shown below.</p>
<p><img src="EnetLLD_Diagram.png" alt="" class="inline" title="Enet Low-Level Driver Block Diagram"/>   </p>
<p>Currently, the PHY driver supports only Clause-22 devices. Clause-45 devices are not supported, but read and write helper functions are provided.</p>
<h1><a class="anchor" id="enetphy_guide_driver"></a>
PHY Driver</h1>
<p>The top-layer of PHY driver is located at <code>source/networking/enet/core/src/phy/enetphy.c</code>. This layer implements the basic APIs that are needed to communicate the driver, such as <code><a class="el" href="group__DRV__ENETPHY.html#ga1d8cebac9cf8a645b504894220106215" title="Open the PHY driver.">EnetPhy_open()</a></code>, <code><a class="el" href="group__DRV__ENETPHY.html#ga82babbc2e9c65ac5dc541c6fc8e33ca3" title="Run PHY state machine.">EnetPhy_tick()</a></code>, <code><a class="el" href="group__DRV__ENETPHY.html#ga1d69a2547cc8cb17c9ccd397ac164378" title="Close the PHY driver.">EnetPhy_close()</a></code>, etc.</p>
<p>The Enet LLD is capable of supporting multiple PHYs running simultaneously; each PHY has its own driver instance, its own state machine and hence will follow independent lifecycle from other PHYs.</p>
<p>The lifecycle of the PHYs is handled by the PHY driver via a state machine implementation. This state machine is composed of the following states:</p>
<ul>
<li><b>FINDING</b>: The driver will remain in this state until the PHY is detected as alive and a device-specific PHY driver has been bound to it.</li>
<li><b>FOUND</b>: The driver will initiate (soft) reset if requested in PHY configuration.</li>
<li><b>RESET_WAIT</b>: The driver will remain in this state while waiting for reset to complete.</li>
<li><b>ENABLE</b>: The driver will put the PHY in normal mode, perform PHY device-specific extended configuration and get common capabilities supported by the MAC port and local PHY device. Depending on the requested mode (auto-negotiation or manual), the PHY will either restart auto-negotiation or manually configure speed and duplexity.</li>
<li><b>LOOPBACK</b>: Last state if PHY loopback is enabled.</li>
<li><b>NWAY_START</b>: The driver will remain in this state while waiting for auto-negotiation to start.</li>
<li><b>NWAY_WAIT</b>: The driver will remain in this state while waiting for auto-negotiation to complete.</li>
<li><b>LINK_WAIT</b>: The driver will remain in this state while waiting for link up.</li>
<li><b>LINKED</b>: The PHY will remain in this state until the link is down, i.e. cable disconnection.</li>
</ul>
<p>The diagram in the figure below provides a simplified view of the state transitions of the PHY state machine.</p>
<p><img src="EnetPhy_FSM_SimplifiedView.png" alt="" class="inline" title="Simplified View of PHY State Machine"/>   </p>
<p>Refer to <a class="el" href="enetphy_guide_top.html#enetphy_guide_appendix_a">Appendix A</a> for a more detailed view of the PHY state machine.</p>
<h2><a class="anchor" id="enetphy_guide_device_specific"></a>
Device-Specific Drivers</h2>
<p>The PHY driver model has been designed to partition device-specific operations from device-agnostic common operations. The former are implemented by PHY device specific drivers, while the latter can be carried out directly by the main PHY driver.</p>
<p>This model facilitates the addition of new drivers for PHY devices not yet supported in the Enet LLD. The <code><a class="el" href="structPhy__DrvObj__t.html">Phy_DrvObj_t</a></code> structure is defined as the interface that device specific drivers must implement. Since this structure is not exposed to the application, its scope is internal to the Enet LLD.</p>
<p><img src="EnetPhy_Drv.png" alt="" class="inline" title="Ethernet PHY Driver Interface"/>   </p>
<p>The members of the <code><a class="el" href="structPhy__DrvObj__t.html">Phy_DrvObj_t</a></code> structure can be mandatory or optional in nature. Optional members can be set to NULL if the PHY doesn't provide an implementation for them. The list below provides a description of the purpose of each <code><a class="el" href="structPhy__DrvObj__t.html">Phy_DrvObj_t</a></code> member.</p>
<ul>
<li><b>name</b>: Driver name.</li>
<li><b>bind</b>: The main PHY driver will call this function to bind the driver handle and register access functions to specific PHY device.</li>
<li><b>isPhyDevSupported()</b>: Function pointer used by the main PHY driver to check if this device specific driver support a given PHY hardware identified by its version (OUI). This function is used during PHY device to driver binding.</li>
<li><b>isMacModeSupported()</b>: The main PHY driver will call this function to check if the device specific driver supports the requested MAC mode (MII, RMII, RGMII, SGMII, etc).</li>
<li><b>config()</b>: The main PHY driver will call this function to allow the driver to perform any device-specific extended configuration. This function is optional and will not be called if the driver sets the function pointer to <code>NULL</code>.</li>
<li><b>reset()</b>: Device specific reset. This function is optional and will not be called if the driver sets the function pointer to <code>NULL</code>.</li>
<li><b>isResetComplete()</b>: The main PHY driver will call this function to check if the reset operation triggered by <code>reset()</code> function has completed. If <code>reset()</code> is provided, <code>isResetComplete()</code> must be provided as well.</li>
<li><b>readExtReg()</b>: The main PHY driver will call this function to read extended registers.</li>
<li><b>writeExtReg()</b>: The main PHY driver will call this function to write extended registers.</li>
<li><p class="startli"><b>printRegs()</b>: The main PHY driver will call this function when <a class="el" href="group__DRV__ENETPHY.html#ga86d2852ee8d820639c56aa26104965fc" title="Print all PHY registers.">EnetPhy_printRegs()</a> is called. This function is optional and will not be called if the driver sets the function pointer to <code>NULL</code>.</p>
<p class="startli">The below functions are optional and can only be supported when the PHY has a built-in PTP clock.</p>
</li>
<li><b>adjPtpFreq()</b>: The main PHY driver will call this function when <a class="el" href="group__DRV__ENETPHY.html#ga1f2bbacde0de1fefe7dbf5e844324851" title="Adjust PHY PTP clock frequency.">EnetPhy_adjPtpFreq()</a> is called to adjust PTP clock frequency.</li>
<li><b>adjPtpPhase()</b>: The main PHY driver will call this function when <a class="el" href="group__DRV__ENETPHY.html#ga6f49b6a8f4260ed3817279c73fcdd53e" title="Adjust PHY PTP clock phase.">EnetPhy_adjPtpPhase()</a> is called to adjust PTP clock phase.</li>
<li><b>getPtpTime()</b>: The main PHY driver will call this function when <a class="el" href="group__DRV__ENETPHY.html#ga3d01b2f12415b08d414b11d17582efc0" title="Get current PHY PTP clock time.">EnetPhy_getPtpTime()</a> is called to get current PHY PTP clock time.</li>
<li><b>setPtpTime()</b>: The main PHY driver will call this function when <a class="el" href="group__DRV__ENETPHY.html#gaf8bb9ad3d5840e91bfe2bb840c8ee034" title="Set PHY PTP clock time.">EnetPhy_setPtpTime()</a> is called to set PHY PTP clock time.</li>
<li><b>getPtpTxTime()</b>: The main PHY driver will call this function when <a class="el" href="group__DRV__ENETPHY.html#gaf8cfa0f6f53343bff002f7d8e75f3fe4" title="Get PHY PTP TX packet timestamp.">EnetPhy_getPtpTxTime()</a> is called to get PHY PTP TX packet timestamp.</li>
<li><b>getPtpRxTime()</b>: The main PHY driver will call this function when <a class="el" href="group__DRV__ENETPHY.html#gaaab7c58d5123053eeb47966f8859fe6b" title="Get PHY PTP RX packet timestamp.">EnetPhy_getPtpRxTime()</a> is called to get PHY PTP RX packet timestamp.</li>
<li><b>waitPtpTxTime()</b>: The main PHY driver will call this function when <a class="el" href="group__DRV__ENETPHY.html#ga8e87a0bdd1d1939ab335cc53f5729c3d" title="Add PHY PTP TX packet info to a waiting TX timestamp list.">EnetPhy_waitPtpTxTime()</a> is called to add PHY PTP TX packet info to a waiting TX timestamp list.</li>
<li><b>procStatusFrame()</b>: The main PHY driver will call this function when <a class="el" href="group__DRV__ENETPHY.html#gab8456a1df856f905983dde40b2a95d99" title="Process PHY status frame.">EnetPhy_procStatusFrame()</a> is called to process PHY status frame.</li>
<li><b>getStatusFrameEthHeader()</b>: The main PHY driver will call this function when <a class="el" href="group__DRV__ENETPHY.html#gad861d859a82140f5c570acb71145f602" title="Get PHY status frame header.">EnetPhy_getStatusFrameEthHeader()</a> is called to get the Ethernet header of the PHY status frame.</li>
<li><b>enablePtp()</b>: The main PHY driver will call this function when <a class="el" href="group__DRV__ENETPHY.html#gaf5d0a5d67fe73b693efcfa6062518b9d" title="Enable/Disable PHY PTP module.">EnetPhy_enablePtp()</a> is called to enable/disable the PHY PTP module.</li>
<li><b>tickDriver()</b>: The main PHY driver will call this function when <a class="el" href="group__DRV__ENETPHY.html#ga62ccd584b1844929926fb9554c95683d" title="Provide timer tick to the driver.">EnetPhy_tickDriver()</a> is called to provide timer tick to the driver.</li>
<li><b>enableEventCapture()</b>: The main PHY driver will call this function when <a class="el" href="group__DRV__ENETPHY.html#ga0dc85abb0de79855f3f8e3b26f48ffb6" title="Enable/Disable an event capture on a PHY GPIO pin.">EnetPhy_enableEventCapture()</a> is called to enable/disable an event capture on a PHY GPIO pin. This function can only be supported when the built-in PTP clock supports event capture.</li>
<li><b>enableTriggerOutput()</b>: The main PHY driver will call this function when <a class="el" href="group__DRV__ENETPHY.html#ga65171003450b027831a898c7c2dfe693" title="Enable/Disable clock trigger on a GPIO pin.">EnetPhy_enableTriggerOutput()</a> is called to enable/disable trigger output on a GPIO pin. This function can only be supported when the built-in PTP clock supports trigger output.</li>
<li><b>getEventTs()</b>: The main PHY driver will call this function when () is called when <a class="el" href="group__DRV__ENETPHY.html#ga6a5b68a158188d891346fb6b74096b31" title="Get event timestamp.">EnetPhy_getEventTs()</a> is called to get event timestamp.</li>
</ul>
<p>The current version of Enet LLD includes the following PHY drivers:</p><ul>
<li>Generic PHY driver.</li>
<li>TI <a href="http://www.ti.com/lit/ds/symlink/dp83867cr.pdf">DP83867</a> RGMII PHY driver.</li>
<li>TI <a href="https://www.ti.com/lit/ds/symlink/dp83869hm.pdf">DP83869</a> RGMII PHY driver.</li>
<li>TI <a href="https://www.ti.com/lit/ds/symlink/dp83822i.pdf">DP83822</a> RMII PHY driver.</li>
<li>TI <a href="https://www.ti.com/lit/ds/symlink/dp83826e.pdf">DP83826</a> RMII PHY driver.</li>
<li>TI <a href="https://www.ti.com/lit/ds/symlink/dp83tg720s-q1.pdf">DP83TG720</a> Automotive PHY driver.</li>
<li>TI <a href="https://www.ti.com/lit/ds/symlink/dp83tc812r-q1.pdf">DP83TC812</a> Automotive PHY driver.</li>
</ul>
<p>The generic PHY driver is a generic case with limited support for IEEE-Standard MII registers. Reuse of PHY generic function by other device-specific drivers is possible when their <code><a class="el" href="structPhy__DrvObj__t.html">Phy_DrvObj_t</a></code> implementation doesn't deviate from standard. The diagram in figure below shows the reuse of extended register read/write functions by the DP83867 driver.</p>
<p><img src="EnetPhy_Drv_Hierarchy.png" alt="" class="inline" title="Ethernet PHY Driver Hierarchy"/>   </p>
<p>Device specific drivers can be found at <code>source/board/ethphy/enet/rtos_drivers/src/*</code>.</p>
<h1><a class="anchor" id="CustomBoardPhySupport"></a>
Custom Board Support</h1>
<hr  />
<p> The MCU+SDK enet driver supports a set of boards for each SoC out of the box</p><ul>
<li>Refer MCU+SDK release notes for platforms/board supported for each SoC</li>
</ul>
<p>The board specific portion of the enet code is auto generated in the file ti_board_config.c for supported boards</p>
<p>For porting enet based applications to custom board the following need to be done: Enable "Custom Board" syscfg option  <style>div.image img[src="CustomBoardSyscfg.png"]{width:30%}</style> </p><div class="image">
<img src="CustomBoardSyscfg.png" alt=""/>
</div>
<ul>
<li>Enabling “Custom Board” will prevent auto generation of board specific code.</li>
<li>A C file will have to be then written that is specific to the board.</li>
</ul>
<h3><a class="anchor" id="autotoc_md1404"></a>
Board config C file</h3>
<p>The board specific file should contain the following</p><ul>
<li><b>const EnetPhy_DrvInfoTbl gEnetPhyDrvTbl</b>: This is a table of ENET PHY drivers supported on the board. Refer Enet custom PHY integration guide for details on how to populate this table <a class="el" href="enetphy_guide_top.html">Ethernet PHY Driver User Guide</a></li>
<li><b>EnetBoard_setupPorts()</b>: This function should setup any board level muxes and configure any SoC level RGMII internal delay/ RMII configuration for the specific port.<ul>
<li>Refer API documentation for mcu_plus_sdk/source/networking/enet/utils/include/enet_board.h for details of function and arguments</li>
</ul>
</li>
<li><b>EnetBoard_getPhyCfg()</b>: This function should return the ETHPHY specific configuration for a given port including any extended phy configuration<ul>
<li>Refer API documentation for mcu_plus_sdk/source/networking/enet/utils/include/enet_board.h for details of function and arguments</li>
</ul>
</li>
<li><b>EnetBoard_getMacAddrList()</b>: This function should populate any board specific MAC addresses that are available on board eeprom. If the board does not have any board specific macAddresses this function should set argument <code>*pAvailMacEntries = 0</code></li>
<li><b>EnetBoard_getId()</b>: This function should return the board id. This is not used anywhere outside this file so the board id returned will depend on the implementation of EnetBoard_setupPorts()/EnetBoard_getPhyCfg() for the custom board if it refers the boardId to determine PHY config/setup ports.</li>
<li>Refer mcu_plus_sdk/examples/networking/enet_layer2_multi_channel<ul>
<li>enet_custom_board_config.c for example illustrating custom board integration</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="enetphy_guide_binding"></a>
PHY to Driver Binding</h2>
<p>The PHY-to-driver binding is the process of selecting the best driver for a PHY device based on the device's unique identifier. This process is done by the main PHY driver upon <em>alive</em> detection of a PHY device and takes place in the <em>FINDING</em> state.</p>
<p>The device unique identifier is read from PHYIDR1 and PHYIDR2 registers and populated into a structure of type <a class="el" href="structEnetPhy__Version.html" title="PHY version (ID).">EnetPhy_Version</a>.</p>
<p><img src="EnetPhy_Version.png" alt="" class="inline" title="Ethernet PHY Version"/>   </p>
<p>The main PHY driver has a <code>gEnetPhyDrvs</code> array which contains all device specific drivers that are registered and that will participate in the search for the best driver for the PHY that had been recently discovered.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="structPhy__DrvObj__t.html">EthPhyDrv_If</a> gEnetPhyDrvs[] =</div>
<div class="line">{</div>
<div class="line">    &amp;gEnetPhyDrvDp83822,   <span class="comment">/* DP83822 */</span></div>
<div class="line">    &amp;gEnetPhyDrvDp83867,   <span class="comment">/* DP83867 */</span></div>
<div class="line">    &amp;gEnetPhyDrvDp83869,   <span class="comment">/* DP83869 */</span></div>
<div class="line">    &amp;gEnetPhyDrvGeneric,   <span class="comment">/* Generic PHY - must be last */</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>In the search process, the main PHY driver will call the <code>isPhyDevSupported()</code> function of each registered driver. The drivers will use the <a class="el" href="structEnetPhy__Version.html" title="PHY version (ID).">EnetPhy_Version</a> which is passed as an argument in order to determine whether the device is supported or not. If it is, <code>isPhyDevSupported()</code> must return <code>true</code> and the search process ends. If not, the search continues with the next registered device.</p>
<p>The generic PHY (which must be the last one in the <code>gEnetPhyDrvs</code> array) will be bound to the device if no other driver can support a given PHY, but the PHY full functionality can't be guaranteed.</p>
<h1><a class="anchor" id="enetphy_guide_implementing"></a>
Implementing a New PHY Driver</h1>
<p>You can find the guide for implementing a new PHY Driver <b><a class="el" href="custom_enetphy_guide.html">here</a></b>.</p>
<h1><a class="anchor" id="mac_to_mac_mode"></a>
MAC2MAC feature (NO-PHY mode)</h1>
<p>You can find the guide to enable MAC2MAC support <b><a class="el" href="enet_mac2mac_top.html">here</a></b>.</p>
<h1><a class="anchor" id="enetphy_guide_appendix"></a>
Appendix</h1>
<h2><a class="anchor" id="enetphy_guide_appendix_a"></a>
Appendix A</h2>
<p>Detailed view of the PHY state machine.</p>
<p><img src="EnetPhy_FSM.png" alt="" class="inline" title="Detailed View of PHY State Machine"/>    </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="astructPhy__DrvObj__t_html"><div class="ttname"><a href="structPhy__DrvObj__t.html">Phy_DrvObj_t</a></div><div class="ttdef"><b>Definition:</b> phy_common.h:239</div></div>
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
